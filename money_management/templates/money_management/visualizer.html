<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualisation des Strat√©gies Money Management</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        header {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            text-align: center;
        }

        h1 {
            color: #1e3c72;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            color: #666;
            font-size: 1.1em;
        }

        .strategies-list {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }

        .strategies-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 10px;
        }

        .strategy-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95em;
            font-weight: 600;
            transition: all 0.3s ease;
            text-align: center;
        }

        .strategy-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .strategy-btn.active {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            box-shadow: 0 5px 15px rgba(245, 87, 108, 0.4);
        }

        .visualization-area {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            display: none;
        }

        .visualization-area.active {
            display: block;
        }

        .strategy-header {
            border-bottom: 3px solid #667eea;
            padding-bottom: 20px;
            margin-bottom: 30px;
        }

        .strategy-title {
            color: #1e3c72;
            font-size: 2em;
            margin-bottom: 10px;
        }

        .strategy-description {
            color: #666;
            font-size: 1.1em;
            line-height: 1.6;
        }

        .content-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .controls-section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
        }

        .controls-header {
            margin-bottom: 20px;
        }

        .controls-title {
            font-size: 1.3em;
            color: #1e3c72;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .reference-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .btn-reference {
            flex: 1;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            font-size: 0.9em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .btn-save {
            background: #28a745;
            color: white;
        }

        .btn-save:hover {
            background: #218838;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .btn-load {
            background: #667eea;
            color: white;
        }

        .btn-load:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-weight: 500;
            color: #555;
        }

        .control-value {
            background: #667eea;
            color: white;
            padding: 4px 12px;
            border-radius: 5px;
            font-weight: 600;
        }

        .slider {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            border: none;
        }

        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
            height: 400px;
        }

        .insights-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 30px;
        }

        .insight-box {
            padding: 20px;
            border-radius: 10px;
            border-left: 5px solid;
        }

        .insight-box.strengths {
            background: #d4edda;
            border-left-color: #28a745;
        }

        .insight-box.weaknesses {
            background: #f8d7da;
            border-left-color: #dc3545;
        }

        .insight-title {
            font-size: 1.2em;
            font-weight: 600;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .insight-list {
            list-style: none;
        }

        .insight-list li {
            padding: 8px 0;
            padding-left: 25px;
            position: relative;
            line-height: 1.5;
        }

        .insight-list li:before {
            content: "‚Ä¢";
            position: absolute;
            left: 8px;
            font-size: 1.5em;
            line-height: 0.9;
        }

        .strengths .insight-list li:before {
            color: #28a745;
        }

        .weaknesses .insight-list li:before {
            color: #dc3545;
        }

        .no-selection {
            text-align: center;
            padding: 100px 20px;
            color: #999;
        }

        .no-selection-icon {
            font-size: 4em;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üìä Visualisation des Strat√©gies Money Management</h1>
            <p class="subtitle">Explorez et comprenez le comportement de chaque strat√©gie de gestion de risque adaptatif</p>
            <div style="display: flex; gap: 15px; justify-content: center; margin-top: 20px;">
                <a href="/" style="padding: 12px 24px; background: #f0f0f0; color: #333; border-radius: 8px; text-decoration: none; font-weight: 600; transition: all 0.3s ease;">üè† Accueil</a>
                <a href="{% url 'money_management:batch_runner' %}" style="padding: 12px 24px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 8px; text-decoration: none; font-weight: 600; transition: all 0.3s ease;">üöÄ Batch Simulations</a>
                <a href="{% url 'money_management:batch_results' %}" style="padding: 12px 24px; background: #f0f0f0; color: #333; border-radius: 8px; text-decoration: none; font-weight: 600; transition: all 0.3s ease;">üìä R√©sultats Batch</a>
            </div>
        </header>

        <div class="strategies-list">
            <div class="strategies-grid" id="strategiesGrid"></div>
        </div>

        <div class="visualization-area" id="visualizationArea">
            <div class="no-selection">
                <div class="no-selection-icon">üéØ</div>
                <h2>S√©lectionnez une strat√©gie ci-dessus</h2>
                <p>Cliquez sur une strat√©gie pour visualiser son comportement et comprendre ses param√®tres</p>
            </div>
        </div>
    </div>

    <script>
        // Donn√©es des strat√©gies avec leurs visualisations
        const strategies = {{ strategies_json|safe }};
        
        let currentChart = null;
        let currentStrategy = null;

        // Initialiser les boutons de strat√©gies
        function initializeStrategies() {
            const grid = document.getElementById('strategiesGrid');
            
            strategies.forEach((strategy, index) => {
                const btn = document.createElement('button');
                btn.className = 'strategy-btn';
                btn.textContent = `S${index + 1}: ${strategy.name}`;
                btn.onclick = () => selectStrategy(index);
                grid.appendChild(btn);
            });
        }

        // S√©lectionner une strat√©gie
        function selectStrategy(index) {
            // Mise √† jour des boutons actifs
            document.querySelectorAll('.strategy-btn').forEach((btn, i) => {
                btn.classList.toggle('active', i === index);
            });

            currentStrategy = strategies[index];
            displayStrategyVisualization(currentStrategy);
        }

        // Afficher la visualisation d'une strat√©gie
        function displayStrategyVisualization(strategy) {
            const area = document.getElementById('visualizationArea');
            area.classList.add('active');

            // Configuration sp√©cifique selon le type de strat√©gie
            const config = getStrategyConfig(strategy);

            area.innerHTML = `
                <div class="strategy-header">
                    <h2 class="strategy-title">${strategy.name}</h2>
                    <p class="strategy-description">${strategy.description}</p>
                </div>

                <div class="content-grid">
                    <div class="controls-section">
                        <div class="controls-header">
                            <h3 class="controls-title">‚öôÔ∏è Param√®tres de la strat√©gie</h3>
                            <div class="reference-buttons">
                                <button class="btn-reference btn-save" onclick="saveReferenceParams()">üíæ Sauvegarder comme r√©f√©rence</button>
                                <button class="btn-reference btn-load" onclick="loadReferenceParams()">üìÇ Charger r√©f√©rence</button>
                            </div>
                        </div>
                        ${generateControls(strategy, config)}
                    </div>

                    <div class="chart-container">
                        <canvas id="strategyChart"></canvas>
                    </div>
                </div>

                <div class="insights-section">
                    <div class="insight-box strengths">
                        <div class="insight-title">‚úÖ Points Forts</div>
                        <ul class="insight-list">
                            ${config.strengths.map(s => `<li>${s}</li>`).join('')}
                        </ul>
                    </div>

                    <div class="insight-box weaknesses">
                        <div class="insight-title">‚ö†Ô∏è Points Faibles</div>
                        <ul class="insight-list">
                            ${config.weaknesses.map(w => `<li>${w}</li>`).join('')}
                        </ul>
                    </div>
                </div>
            `;

            // Cr√©er le graphique
            createChart(strategy, config);
        }

        // G√©n√©rer les contr√¥les (sliders) pour les param√®tres
        function generateControls(strategy, config) {
            let html = '';
            
            for (const [param, value] of Object.entries(strategy.params)) {
                const paramConfig = config.paramRanges[param];
                if (!paramConfig) continue;

                html += `
                    <div class="control-group">
                        <div class="control-label">
                            <span>${paramConfig.label}</span>
                            <span class="control-value" id="value_${param}">${value}${paramConfig.unit}</span>
                        </div>
                        <input type="range" 
                               class="slider" 
                               id="slider_${param}"
                               min="${paramConfig.min}" 
                               max="${paramConfig.max}" 
                               step="${paramConfig.step}" 
                               value="${value}"
                               oninput="updateParameter('${param}', this.value, '${paramConfig.unit}')">
                    </div>
                `;
            }

            return html;
        }

        // Mettre √† jour un param√®tre et recharger le graphique
        function updateParameter(param, value, unit) {
            document.getElementById(`value_${param}`).textContent = value + unit;
            currentStrategy.params[param] = parseFloat(value);
            
            // Recr√©er le graphique avec les nouvelles valeurs
            const config = getStrategyConfig(currentStrategy);
            createChart(currentStrategy, config);
        }

        // Sauvegarder les param√®tres actuels comme r√©f√©rence
        async function saveReferenceParams() {
            if (!currentStrategy) {
                alert('Aucune strat√©gie s√©lectionn√©e');
                return;
            }

            try {
                const response = await fetch(`/money-management/reference/${currentStrategy.key}/save/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        params: currentStrategy.params
                    })
                });

                const result = await response.json();
                
                if (result.success) {
                    alert(`‚úÖ ${result.message}`);
                } else {
                    alert(`‚ùå Erreur: ${result.error}`);
                }
            } catch (error) {
                alert(`‚ùå Erreur de sauvegarde: ${error.message}`);
            }
        }

        // Charger les param√®tres de r√©f√©rence
        async function loadReferenceParams() {
            if (!currentStrategy) {
                alert('Aucune strat√©gie s√©lectionn√©e');
                return;
            }

            try {
                const response = await fetch(`/money-management/reference/${currentStrategy.key}/load/`);
                const result = await response.json();
                
                if (result.success) {
                    // Mettre √† jour les param√®tres de la strat√©gie
                    currentStrategy.params = result.params;
                    
                    // Mettre √† jour l'interface
                    const config = getStrategyConfig(currentStrategy);
                    for (const [param, value] of Object.entries(result.params)) {
                        const paramConfig = config.paramRanges[param];
                        if (paramConfig) {
                            const slider = document.getElementById(`slider_${param}`);
                            const valueDisplay = document.getElementById(`value_${param}`);
                            if (slider && valueDisplay) {
                                slider.value = value;
                                valueDisplay.textContent = value + paramConfig.unit;
                            }
                        }
                    }
                    
                    // Recr√©er le graphique
                    createChart(currentStrategy, config);
                    
                    alert('‚úÖ Param√®tres de r√©f√©rence charg√©s');
                } else {
                    alert(`‚ÑπÔ∏è ${result.error}`);
                }
            } catch (error) {
                alert(`‚ùå Erreur de chargement: ${error.message}`);
            }
        }

        // Cr√©er le graphique selon le type de strat√©gie
        function createChart(strategy, config) {
            if (currentChart) {
                currentChart.destroy();
            }

            const ctx = document.getElementById('strategyChart').getContext('2d');
            const data = config.generateData(strategy.params);

            currentChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.labels,
                    datasets: data.datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: data.datasets.length > 1,
                            position: 'top'
                        },
                        title: {
                            display: true,
                            text: config.chartTitle,
                            font: {
                                size: 16,
                                weight: 'bold'
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: config.xAxisLabel
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Risque sur capital (%)'
                            },
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        // Configuration sp√©cifique pour chaque type de strat√©gie
        function getStrategyConfig(strategy) {
            const key = strategy.key;

            // ============ S1, S2, S3: Strat√©gies bas√©es sur le Drawdown ============
            if (key === 'strategy_1' || key === 'strategy_2' || key === 'strategy_3') {
                return {
                    chartTitle: '√âvolution du Risque en fonction du Drawdown',
                    xAxisLabel: 'Drawdown (%)',
                    paramRanges: {
                        'base_risk': { label: 'Risque de base', min: 0.1, max: 5, step: 0.1, unit: '%' },
                        'dd1': { label: 'Seuil DD1', min: 1, max: 30, step: 1, unit: '%' },
                        'dd2': { label: 'Seuil DD2', min: 10, max: 50, step: 1, unit: '%' },
                        'dd_step': { label: 'Palier DD', min: 1, max: 15, step: 1, unit: '%' },
                        'decay': { label: 'D√©croissance', min: 0.5, max: 0.95, step: 0.05, unit: '' },
                        'dd_threshold': { label: 'Seuil DD', min: 5, max: 30, step: 1, unit: '%' },
                        'safe_risk': { label: 'Risque s√©curit√©', min: 0.1, max: 1, step: 0.05, unit: '%' },
                        'min_risk': { label: 'Risque MINIMUM', min: 0.05, max: 2, step: 0.05, unit: '%' }
                    },
                    generateData: (params) => {
                        const labels = [];
                        const risks = [];
                        
                        // G√©n√©rer des points de DD de 0% √† -50%
                        for (let dd = 0; dd >= -50; dd -= 1) {
                            labels.push(dd.toFixed(0));
                            
                            // Calculer le risque selon la strat√©gie
                            let risk;
                            if (key === 'strategy_1') {
                                // Drawdown Lin√©aire
                                const base_risk = params.base_risk || 1;
                                const dd1 = params.dd1 || 5;
                                const dd2 = params.dd2 || 20;
                                
                                if (dd >= -dd1) {
                                    risk = base_risk;
                                } else if (dd <= -dd2) {
                                    risk = base_risk * 0.3;
                                } else {
                                    const ratio = (Math.abs(dd) - dd1) / (dd2 - dd1);
                                    risk = base_risk * (1 - 0.7 * ratio);
                                }
                            } else if (key === 'strategy_2') {
                                // Drawdown G√©om√©trique
                                const base_risk = params.base_risk || 1;
                                const dd_step = params.dd_step || 5;
                                const decay = params.decay || 0.8;
                                const min_risk = params.min_risk || 0.1;
                                
                                const steps = Math.max(0, Math.floor(Math.abs(dd) / dd_step));
                                risk = base_risk * Math.pow(decay, steps);
                                
                                // Appliquer le seuil minimum
                                risk = Math.max(min_risk, risk);
                            } else {
                                // Mode S√©curit√©
                                const base_risk = params.base_risk || 1;
                                const dd_threshold = params.dd_threshold || 15;
                                const safe_risk = params.safe_risk || 0.25;
                                
                                risk = dd < -dd_threshold ? safe_risk : base_risk;
                            }
                            
                            risks.push(risk);
                        }
                        
                        return {
                            labels: labels,
                            datasets: [{
                                label: 'Risque (%)',
                                data: risks,
                                borderColor: '#667eea',
                                backgroundColor: 'rgba(102, 126, 234, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0.4
                            }]
                        };
                    },
                    strengths: [
                        'Prot√®ge efficacement le capital pendant les phases de pertes en r√©duisant progressivement l\'exposition',
                        'Adaptation automatique et instantan√©e au contexte de march√© sans intervention manuelle',
                        'R√©duit significativement le risque de ruine progressive lors de s√©quences d√©favorables',
                        'Permet de conserver du capital pour profiter de la r√©cup√©ration future'
                    ],
                    weaknesses: [
                        'Peut limiter les gains potentiels en p√©riode de r√©cup√©ration car le risque reste r√©duit',
                        'Tr√®s sensible au param√©trage des seuils : des valeurs mal choisies peuvent √™tre trop ou pas assez conservatrices',
                        'Ne r√©agit pas aux s√©ries de gains, manquant des opportunit√©s de capitalisation',
                        'Peut cr√©er une sortie difficile du drawdown si les seuils sont trop stricts'
                    ]
                };
            }

            // ============ S4: DD Max Historique ============
            if (key === 'strategy_4') {
                return {
                    chartTitle: 'Risque en fonction du Ratio DD Actuel / DD Max',
                    xAxisLabel: 'Ratio DD / DD Max',
                    paramRanges: {
                        'base_risk': { label: 'Risque de base', min: 0.1, max: 5, step: 0.1, unit: '%' },
                        'ratio_threshold': { label: 'Seuil de ratio', min: 0.5, max: 1.0, step: 0.05, unit: '' },
                        'low_risk': { label: 'Risque r√©duit', min: 0.1, max: 2, step: 0.1, unit: '%' }
                    },
                    generateData: (params) => {
                        const labels = [];
                        const risks = [];
                        const base_risk = params.base_risk || 1.0;
                        const ratio_threshold = params.ratio_threshold || 0.7;
                        const low_risk = params.low_risk || 0.5;
                        
                        for (let ratio = 0; ratio <= 1; ratio += 0.05) {
                            labels.push(ratio.toFixed(2));
                            risks.push(ratio > ratio_threshold ? low_risk : base_risk);
                        }
                        
                        return {
                            labels: labels,
                            datasets: [{
                                label: 'Risque (%)',
                                data: risks,
                                borderColor: '#667eea',
                                backgroundColor: 'rgba(102, 126, 234, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0.4
                            }]
                        };
                    },
                    strengths: [
                        'Apprend de l\'historique : utilise le pire drawdown v√©cu comme r√©f√©rence pour contextualiser la situation actuelle',
                        '√âvite les sur-r√©actions en comparant le DD actuel √† l\'exp√©rience pass√©e plut√¥t qu\'√† des seuils arbitraires',
                        'Efficace pour g√©rer des conditions de march√© similaires √† celles d√©j√† rencontr√©es',
                        'R√©duit le risque uniquement quand on approche vraiment d\'une zone dangereuse connue'
                    ],
                    weaknesses: [
                        'N√©cessite un historique suffisant : inefficace en d√©but de trading (manque de r√©f√©rence)',
                        'Peut √™tre trop permissif si le DD max historique √©tait exceptionnel (ex: flash crash)',
                        'Ne prot√®ge pas contre un nouveau type de drawdown jamais rencontr√© auparavant',
                        'La strat√©gie √©volue dans le temps : difficile √† backtester de mani√®re coh√©rente'
                    ]
                };
            }

            // ============ S5, S6: Scaling sur Capital ============
            if (key === 'strategy_5' || key === 'strategy_6') {
                return {
                    chartTitle: 'Risque en fonction de la Performance (%)',
                    xAxisLabel: 'Performance par rapport au capital initial (%)',
                    paramRanges: {
                        'base_risk': { label: 'Risque de base', min: 0.1, max: 5, step: 0.1, unit: '%' },
                        'gain_step': { label: 'Palier de gain', min: 5, max: 30, step: 5, unit: '%' },
                        'increment': { label: 'Incr√©ment risque', min: 0.05, max: 0.5, step: 0.05, unit: '%' },
                        'growth_rate': { label: 'Taux croissance', min: 1.05, max: 1.3, step: 0.05, unit: '' },
                        'step': { label: 'Palier', min: 5, max: 20, step: 5, unit: '%' },
                        'max_risk': { label: 'Risque maximum', min: 1, max: 10, step: 0.5, unit: '%' }
                    },
                    generateData: (params) => {
                        const labels = [];
                        const risks = [];
                        const base_risk = params.base_risk || 1.0;
                        const max_risk = params.max_risk || 5.0;
                        
                        for (let perf = 0; perf <= 100; perf += 5) {
                            labels.push(perf.toFixed(0));
                            
                            let risk;
                            if (key === 'strategy_5') {
                                const gain_step = params.gain_step || 10;
                                const increment = params.increment || 0.1;
                                const steps = Math.floor(perf / gain_step);
                                risk = base_risk + (steps * increment);
                            } else {
                                const growth_rate = params.growth_rate || 1.1;
                                const step = params.step || 10;
                                const steps = Math.floor(perf / step);
                                risk = base_risk * Math.pow(growth_rate, steps);
                            }
                            
                            risks.push(Math.min(risk, max_risk)); // Cap au max_risk param√©trable
                        }
                        
                        return {
                            labels: labels,
                            datasets: [{
                                label: 'Risque (%)',
                                data: risks,
                                borderColor: '#28a745',
                                backgroundColor: 'rgba(40, 167, 69, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0.4
                            }]
                        };
                    },
                    strengths: [
                        'Capitalise sur les p√©riodes de gains en augmentant progressivement l\'exposition au march√©',
                        'Profite de l\'effet de levier du capital cumul√© pour acc√©l√©rer la croissance du compte',
                        'Psychologiquement gratifiant : vous prenez plus de risque quand vous gagnez',
                        'Permet d\'atteindre des objectifs ambitieux plus rapidement en p√©riode favorable'
                    ],
                    weaknesses: [
                        'Tr√®s risqu√© en p√©riode de retournement : un gros risque juste avant un krach peut tout an√©antir',
                        'Amplifie les pertes apr√®s une p√©riode de gains si le march√© se retourne',
                        'Peut cr√©er une surconfiance dangereuse et pousser √† prendre trop de risques',
                        'N√©cessite une discipline stricte pour revenir au risque de base apr√®s un drawdown'
                    ]
                };
            }

            // ============ S7: Risk Reset ============
            if (key === 'strategy_7') {
                return {
                    chartTitle: 'Risque en fonction du Nombre de Trades sans ATH',
                    xAxisLabel: 'Trades sans nouveau plus-haut',
                    paramRanges: {
                        'base_risk': { label: 'Risque de base', min: 0.1, max: 5, step: 0.1, unit: '%' },
                        'plateau_step': { label: 'Palier de plateau', min: 3, max: 20, step: 1, unit: ' trades' },
                        'reset_risk': { label: 'Risque reset', min: 0.5, max: 3, step: 0.1, unit: '%' }
                    },
                    generateData: (params) => {
                        const labels = [];
                        const risks = [];
                        const base_risk = params.base_risk || 1.0;
                        const plateau_step = params.plateau_step || 5;
                        const reset_risk = params.reset_risk || 1.5;
                        
                        for (let trades = 0; trades <= 30; trades++) {
                            labels.push(trades.toString());
                            risks.push(trades >= plateau_step ? reset_risk : base_risk);
                        }
                        
                        return {
                            labels: labels,
                            datasets: [{
                                label: 'Risque (%)',
                                data: risks,
                                borderColor: '#ffc107',
                                backgroundColor: 'rgba(255, 193, 7, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0
                            }]
                        };
                    },
                    strengths: [
                        'Combat la stagnation : force une tentative de sortie de plateau en augmentant l\'exposition',
                        'Utile pour les march√©s en range o√π il faut prendre plus de risque pour sortir de la zone',
                        '√âvite la paralysie d√©cisionnelle en imposant une r√®gle m√©canique d\'action',
                        'Peut acc√©l√©rer la sortie d\'une p√©riode de stagnation prolong√©e'
                    ],
                    weaknesses: [
                        'Dangereux en drawdown prolong√© : augmente le risque au pire moment possible',
                        'Peut acc√©l√©rer la ruine si le plateau est d√ª √† une mauvaise configuration de march√©',
                        'Ne distingue pas entre stagnation saine et drawdown d√©guis√©',
                        'Psychologiquement difficile : augmenter le risque apr√®s une s√©rie sans gains va contre l\'instinct'
                    ]
                };
            }

            // ============ S8: ATH Distance ============
            if (key === 'strategy_8') {
                return {
                    chartTitle: 'Risque en fonction de la Distance √† l\'ATH',
                    xAxisLabel: 'Distance √† l\'ATH (%)',
                    paramRanges: {
                        'base_risk': { label: 'Risque de base', min: 0.1, max: 5, step: 0.1, unit: '%' },
                        'ath_distance': { label: 'Distance boost', min: 2, max: 20, step: 1, unit: '%' },
                        'boost_risk': { label: 'Risque boost√©', min: 1, max: 3, step: 0.1, unit: '%' }
                    },
                    generateData: (params) => {
                        const labels = [];
                        const risks = [];
                        const base_risk = params.base_risk || 1.0;
                        const ath_distance = params.ath_distance || 10;
                        const boost_risk = params.boost_risk || 1.2;
                        
                        for (let dist = 0; dist <= 30; dist++) {
                            labels.push(dist.toFixed(0));
                            risks.push(dist <= ath_distance ? boost_risk : base_risk);
                        }
                        
                        return {
                            labels: labels,
                            datasets: [{
                                label: 'Risque (%)',
                                data: risks,
                                borderColor: '#17a2b8',
                                backgroundColor: 'rgba(23, 162, 184, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0
                            }]
                        };
                    },
                    strengths: [
                        'Capitalise sur la momentum : prend plus de risque quand on est proche du sommet (tendance haussi√®re)',
                        'Profite des p√©riodes de forte performance pour maximiser les gains',
                        'R√©duit automatiquement le risque en s\'√©loignant du pic (protection contre les retournements)',
                        'Align√© avec la psychologie gagnante : plus agressif en position de force'
                    ],
                    weaknesses: [
                        'Peut manquer des opportunit√©s de r√©cup√©ration en r√©duisant le risque apr√®s un DD',
                        'Vuln√©rable aux pics suivis de corrections brutales (bull trap)',
                        'Favorise le trading en tendance mais p√©nalise les march√©s en range',
                        'Peut cr√©er une fausse s√©curit√© : √™tre proche de l\'ATH ne garantit pas la continuation'
                    ]
                };
            }

            // ============ S9: Anti-Martingale Invers√©e ============
            if (key === 'strategy_9') {
                return {
                    chartTitle: 'Risque selon Dernier R√©sultat (Anti-Martingale Invers√©e)',
                    xAxisLabel: 'R√©sultat du dernier trade',
                    paramRanges: {
                        'base_risk': { label: 'Risque de base', min: 0.1, max: 5, step: 0.1, unit: '%' },
                        'up_factor': { label: 'Facteur apr√®s PERTE', min: 1.1, max: 2, step: 0.1, unit: 'x' },
                        'down_factor': { label: 'Facteur apr√®s GAIN', min: 0.5, max: 0.9, step: 0.05, unit: 'x' },
                        'min_risk': { label: 'Risque MINIMUM', min: 0.05, max: 2, step: 0.05, unit: '%' },
                        'max_risk': { label: 'Risque MAXIMUM', min: 2, max: 10, step: 0.5, unit: '%' }
                    },
                    generateData: (params) => {
                        const labels = ['GAIN', 'PERTE'];
                        const base_risk = params.base_risk || 1.0;
                        const up_factor = params.up_factor || 1.2;
                        const down_factor = params.down_factor || 0.8;
                        const min_risk = params.min_risk || 0.1;
                        const max_risk = params.max_risk || 5.0;
                        
                        // Calculer les risques avec application des seuils min/max
                        // INVERS√â : down_factor apr√®s GAIN, up_factor apr√®s PERTE
                        let risk_after_gain = base_risk * down_factor;
                        let risk_after_loss = base_risk * up_factor;
                        
                        risk_after_gain = Math.max(min_risk, Math.min(risk_after_gain, max_risk));
                        risk_after_loss = Math.max(min_risk, Math.min(risk_after_loss, max_risk));
                        
                        const risks = [risk_after_gain, risk_after_loss];
                        
                        return {
                            labels: labels,
                            datasets: [{
                                label: 'Risque (%)',
                                data: risks,
                                backgroundColor: ['rgba(40, 167, 69, 0.7)', 'rgba(220, 53, 69, 0.7)'],
                                borderColor: ['#28a745', '#dc3545'],
                                borderWidth: 2
                            }]
                        };
                    },
                    strengths: [
                        'Contre-intuitif mais logique : r√©duit le risque apr√®s gain (prudence apr√®s succ√®s)',
                        'Augmente le risque apr√®s perte (profite d\'un potentiel retour √† la moyenne)',
                        'Peut aider √† r√©cup√©rer rapidement apr√®s des pertes si le march√© se retourne',
                        '√âvite de sur-risquer apr√®s des s√©ries gagnantes qui pourraient se terminer brutalement'
                    ],
                    weaknesses: [
                        'Psychologiquement difficile : augmenter le risque apr√®s perte va contre l\'instinct',
                        'Dangereux en s√©rie de pertes prolong√©e : le risque continue d\'augmenter',
                        'R√©duit les gains potentiels en p√©riode gagnante (baisse du risque)',
                        'Suppose un retour √† la moyenne qui n\'est pas garanti en trading'
                    ]
                };
            }

            // ============ S10: 3 Pertes Cons√©cutives ============
            if (key.includes('strategy_10')) {
                return {
                    chartTitle: 'Risque selon Pertes Cons√©cutives',
                    xAxisLabel: 'Nombre de pertes cons√©cutives',
                    paramRanges: {
                        'base_risk': { label: 'Risque de base', min: 0.1, max: 5, step: 0.1, unit: '%' },
                        'loss_streak': { label: 'Seuil de pertes', min: 2, max: 10, step: 1, unit: ' trades' },
                        'reduced_risk': { label: 'Risque r√©duit', min: 0.1, max: 2, step: 0.1, unit: '%' }
                    },
                    generateData: (params) => {
                        const labels = [];
                        const risks = [];
                        const base_risk = params.base_risk || 1.0;
                        const loss_streak = params.loss_streak || 3;
                        const reduced_risk = params.reduced_risk || 0.5;
                        
                        for (let n = 0; n <= 10; n++) {
                            labels.push(n.toString());
                            risks.push(n >= loss_streak ? reduced_risk : base_risk);
                        }
                        
                        return {
                            labels: labels,
                            datasets: [{
                                label: 'Risque (%)',
                                data: risks,
                                borderColor: '#dc3545',
                                backgroundColor: 'rgba(220, 53, 69, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0
                            }]
                        };
                    },
                    strengths: [
                        'Protection simple et efficace contre les s√©ries de pertes',
                        'R√©duit automatiquement l\'exposition en p√©riode difficile',
                        'Limite les d√©g√¢ts : √©vite d\'aggraver une mauvaise passe',
                        'Facile √† comprendre et √† impl√©menter'
                    ],
                    weaknesses: [
                        'Peut rater des opportunit√©s de r√©cup√©ration en restant trop prudent',
                        'Ne d√©tecte pas la fin de la s√©rie noire : reste en mode r√©duit',
                        'Arbitraire : pourquoi 3 pertes et pas 2 ou 4 ?',
                        'Ne tient pas compte de l\'ampleur des pertes (3x-0.5R vs 3x-3R)'
                    ]
                };
            }

            // ============ S11: Gestion Grosses Pertes ============
            if (key.includes('strategy_11')) {
                return {
                    chartTitle: 'Risque selon Ampleur de la Derni√®re Perte',
                    xAxisLabel: 'Perte du dernier trade (en R)',
                    paramRanges: {
                        'base_risk': { label: 'Risque de base', min: 0.1, max: 5, step: 0.1, unit: '%' },
                        'threshold_R': { label: 'Seuil de perte', min: 1, max: 10, step: 0.5, unit: 'R' },
                        'emergency_risk': { label: 'Risque d\'urgence', min: 0.1, max: 1, step: 0.05, unit: '%' }
                    },
                    generateData: (params) => {
                        const labels = [];
                        const risks = [];
                        const base_risk = params.base_risk || 1.0;
                        const threshold_R = params.threshold_R || 3;
                        const emergency_risk = params.emergency_risk || 0.3;
                        
                        for (let loss = 0; loss <= 10; loss += 0.5) {
                            labels.push(loss.toFixed(1) + 'R');
                            risks.push(loss >= threshold_R ? emergency_risk : base_risk);
                        }
                        
                        return {
                            labels: labels,
                            datasets: [{
                                label: 'Risque (%)',
                                data: risks,
                                borderColor: '#e74c3c',
                                backgroundColor: 'rgba(231, 76, 60, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0
                            }]
                        };
                    },
                    strengths: [
                        'R√©agit √† l\'ampleur des pertes, pas juste au nombre',
                        'Protection d\'urgence apr√®s un trade catastrophique',
                        'Permet de reprendre progressivement apr√®s un choc',
                        '√âvite l\'effet domino : une grosse perte n\'entra√Æne pas d\'autres grosses pertes'
                    ],
                    weaknesses: [
                        'Bas√© uniquement sur le dernier trade : ignore l\'historique r√©cent',
                        'Peut surr√©agir √† une perte isol√©e dans un contexte par ailleurs sain',
                        'Ne distingue pas grosse perte malchanceuse vs erreur de trading',
                        'Difficile de sortir du mode urgence : un seul trade ne suffit pas'
                    ]
                };
            }

            // ============ S12: Anti-Martingale Classique ============
            if (key.includes('strategy_12')) {
                return {
                    chartTitle: 'Risque selon Dernier R√©sultat (Anti-Martingale)',
                    xAxisLabel: 'R√©sultat du dernier trade',
                    paramRanges: {
                        'base_risk': { label: 'Risque de base', min: 0.1, max: 5, step: 0.1, unit: '%' },
                        'up_factor': { label: 'Facteur apr√®s GAIN', min: 1.1, max: 2, step: 0.1, unit: 'x' },
                        'down_factor': { label: 'Facteur apr√®s PERTE', min: 0.5, max: 0.9, step: 0.05, unit: 'x' },
                        'min_risk': { label: 'Risque MINIMUM', min: 0.05, max: 2, step: 0.05, unit: '%' },
                        'max_risk': { label: 'Risque MAXIMUM', min: 2, max: 10, step: 0.5, unit: '%' }
                    },
                    generateData: (params) => {
                        const labels = ['PERTE', 'GAIN'];
                        const base_risk = params.base_risk || 1.0;
                        const up_factor = params.up_factor || 1.2;
                        const down_factor = params.down_factor || 0.8;
                        const min_risk = params.min_risk || 0.1;
                        const max_risk = params.max_risk || 5.0;
                        
                        // Calculer les risques avec application des seuils min/max
                        let risk_after_loss = base_risk * down_factor;
                        let risk_after_gain = base_risk * up_factor;
                        
                        risk_after_loss = Math.max(min_risk, Math.min(risk_after_loss, max_risk));
                        risk_after_gain = Math.max(min_risk, Math.min(risk_after_gain, max_risk));
                        
                        const risks = [risk_after_loss, risk_after_gain];
                        
                        return {
                            labels: labels,
                            datasets: [{
                                label: 'Risque (%)',
                                data: risks,
                                backgroundColor: ['rgba(220, 53, 69, 0.7)', 'rgba(40, 167, 69, 0.7)'],
                                borderColor: ['#dc3545', '#28a745'],
                                borderWidth: 2
                            }]
                        };
                    },
                    strengths: [
                        'Classique et √©prouv√© : augmente le risque apr√®s gain, r√©duit apr√®s perte',
                        'Capitalise sur les s√©ries gagnantes (momentum)',
                        'Prot√®ge le capital en p√©riode difficile',
                        'Psychologiquement align√© : on ose plus apr√®s succ√®s'
                    ],
                    weaknesses: [
                        'Peut manquer le d√©but d\'un rebond (risque r√©duit apr√®s pertes)',
                        'Vuln√©rable aux retournements brutaux apr√®s s√©ries gagnantes',
                        'Suppose que les r√©sultats sont corr√©l√©s (momentum) - pas toujours vrai',
                        'Simple binaire : ne tient pas compte de l\'ampleur du gain/perte'
                    ]
                };
            }

            // ============ S13: S√©rie de Gains ============
            if (key.includes('strategy_13')) {
                return {
                    chartTitle: 'Risque selon Gains Cons√©cutifs',
                    xAxisLabel: 'Nombre de gains cons√©cutifs',
                    paramRanges: {
                        'base_risk': { label: 'Risque de base', min: 0.1, max: 5, step: 0.1, unit: '%' },
                        'gain_streak': { label: 'Seuil de gains', min: 2, max: 10, step: 1, unit: ' trades' },
                        'boosted_risk': { label: 'Risque boost√©', min: 1, max: 5, step: 0.1, unit: '%' }
                    },
                    generateData: (params) => {
                        const labels = [];
                        const risks = [];
                        const base_risk = params.base_risk || 1.0;
                        const gain_streak = params.gain_streak || 3;
                        const boosted_risk = params.boosted_risk || 1.5;
                        
                        for (let n = 0; n <= 10; n++) {
                            labels.push(n.toString());
                            risks.push(n >= gain_streak ? boosted_risk : base_risk);
                        }
                        
                        return {
                            labels: labels,
                            datasets: [{
                                label: 'Risque (%)',
                                data: risks,
                                borderColor: '#28a745',
                                backgroundColor: 'rgba(40, 167, 69, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0
                            }]
                        };
                    },
                    strengths: [
                        'Capitalise sur le momentum : acc√©l√®re quand √ßa marche',
                        'Maximise les profits pendant les bonnes p√©riodes',
                        'Psychologiquement positif : r√©compense les succ√®s',
                        'Permet de compenser rapidement les pertes pass√©es'
                    ],
                    weaknesses: [
                        'TR√àS DANGEREUX : augmente le risque juste avant le retournement',
                        'Une correction brutale apr√®s boost = pertes massives',
                        'Suppose que les gains sont corr√©l√©s - souvent faux',
                        'Peut transformer une belle s√©rie en catastrophe'
                    ]
                };
            }

            // ============ S12: Moyenne Mobile des Gains/Pertes ============
            if (key.includes('strategy_12')) {
                return {
                    chartTitle: 'Risque en fonction de la Moyenne Mobile des R√©sultats',
                    xAxisLabel: 'Moyenne des 10 derniers trades (R)',
                    paramRanges: {
                        'base_risk': { label: 'Risque de base', min: 0.1, max: 5, step: 0.1, unit: '%' },
                        'window': { label: 'Fen√™tre', min: 5, max: 30, step: 5, unit: ' trades' },
                        'scale': { label: '√âchelle', min: 0.5, max: 2, step: 0.1, unit: '' }
                    },
                    generateData: (params) => {
                        const labels = [];
                        const risks = [];
                        const base_risk = params.base_risk || 1.0;
                        const scale = params.scale || 1;
                        
                        for (let avg = -2; avg <= 2; avg += 0.2) {
                            labels.push(avg.toFixed(1));
                            const risk = Math.max(0.25 * base_risk, base_risk * (1 + avg * scale));
                            risks.push(Math.min(risk, 3 * base_risk));
                        }
                        
                        return {
                            labels: labels,
                            datasets: [{
                                label: 'Risque (%)',
                                data: risks,
                                borderColor: '#9c27b0',
                                backgroundColor: 'rgba(156, 39, 176, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0.4
                            }]
                        };
                    },
                    strengths: [
                        'Lisse les variations : moins r√©actif aux trades individuels, regarde la tendance globale',
                        'Adapt√© aux strat√©gies avec esp√©rance positive mais forte variance',
                        'R√©duit les sur-r√©actions √©motionnelles en se basant sur une fen√™tre statistique',
                        'Peut identifier les changements de r√©gime de march√© √† travers la performance moyenne'
                    ],
                    weaknesses: [
                        'R√©action retard√©e : met du temps √† d√©tecter un changement de contexte',
                        'Peut maintenir un risque √©lev√© trop longtemps apr√®s un retournement',
                        'N√©cessite un param√©trage d√©licat de la fen√™tre (trop court = bruit, trop long = lag)',
                        'Moins efficace en d√©but de trading (fen√™tre incompl√®te)'
                    ]
                };
            }

            // ============ S13: Volatilit√© des R√©sultats ============
            if (key.includes('strategy_13')) {
                return {
                    chartTitle: 'Risque en fonction de la Volatilit√© des Trades',
                    xAxisLabel: '√âcart-type des r√©sultats (R)',
                    paramRanges: {
                        'base_risk': { label: 'Risque de base', min: 0.1, max: 5, step: 0.1, unit: '%' },
                        'low_vol': { label: 'Vol faible', min: 0.5, max: 2, step: 0.1, unit: 'R' },
                        'high_vol': { label: 'Vol √©lev√©e', min: 2, max: 5, step: 0.5, unit: 'R' },
                        'low_risk': { label: 'Risque vol faible', min: 1, max: 3, step: 0.1, unit: '%' },
                        'high_risk': { label: 'Risque vol haute', min: 0.1, max: 1, step: 0.1, unit: '%' }
                    },
                    generateData: (params) => {
                        const labels = [];
                        const risks = [];
                        const low_vol = params.low_vol || 1;
                        const high_vol = params.high_vol || 3;
                        const low_risk = params.low_risk || 1.5;
                        const high_risk = params.high_risk || 0.5;
                        
                        for (let vol = 0; vol <= 5; vol += 0.2) {
                            labels.push(vol.toFixed(1));
                            
                            let risk;
                            if (vol <= low_vol) {
                                risk = low_risk;
                            } else if (vol >= high_vol) {
                                risk = high_risk;
                            } else {
                                const ratio = (vol - low_vol) / (high_vol - low_vol);
                                risk = low_risk - (ratio * (low_risk - high_risk));
                            }
                            
                            risks.push(risk);
                        }
                        
                        return {
                            labels: labels,
                            datasets: [{
                                label: 'Risque (%)',
                                data: risks,
                                borderColor: '#e91e63',
                                backgroundColor: 'rgba(233, 30, 99, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0.4
                            }]
                        };
                    },
                    strengths: [
                        'Tr√®s intelligent : adapte le risque √† la pr√©visibilit√© du march√©, pas juste aux r√©sultats',
                        'Augmente le risque en p√©riode de faible volatilit√© (r√©sultats stables et pr√©visibles)',
                        'R√©duit le risque en p√©riode chaotique m√™me si la performance moyenne est bonne',
                        'Excellent pour d√©tecter les changements de r√©gime de march√© (calme ‚Üí volatil)'
                    ],
                    weaknesses: [
                        'N√©cessite un historique suffisant pour calculer une volatilit√© significative',
                        'Peut r√©duire le risque pendant des p√©riodes volatiles mais tr√®s profitables',
                        'Complexe √† param√©trer : les seuils de volatilit√© d√©pendent de la strat√©gie de trading',
                        'Sensible aux outliers : un seul trade exceptionnel peut fausser la volatilit√©'
                    ]
                };
            }

            // ============ S14: Heat Ramp ============
            if (key.includes('strategy_14')) {
                return {
                    chartTitle: 'Augmentation du risque selon les gains cons√©cutifs',
                    xAxisLabel: 'Nombre de gains cons√©cutifs',
                    paramRanges: {
                        'base_risk': { label: 'Risque de base', min: 0.1, max: 5, step: 0.1, unit: '%' },
                        'ramp_factor': { label: 'Augmentation par gain', min: 0.05, max: 1, step: 0.05, unit: '%' },
                        'streak_limit': { label: 'Limite de s√©rie', min: 1, max: 10, step: 1, unit: ' gains' },
                        'max_risk': { label: 'Risque maximum', min: 1, max: 10, step: 0.5, unit: '%' }
                    },
                    generateData: (params) => {
                        const labels = [];
                        const risks = [];
                        
                        const base_risk = params.base_risk || 1.0;
                        const ramp_factor = params.ramp_factor || 0.1;
                        const streak_limit = params.streak_limit || 5;
                        const max_risk = params.max_risk || 5.0;
                        
                        for (let wins = 0; wins <= 10; wins++) {
                            labels.push(wins.toString());
                            const effective_wins = Math.min(wins, streak_limit);
                            const risk = Math.min(base_risk + (effective_wins * ramp_factor), max_risk);
                            risks.push(risk);
                        }
                        
                        return {
                            labels: labels,
                            datasets: [{
                                label: 'Risque (%)',
                                data: risks,
                                borderColor: '#ff6b6b',
                                backgroundColor: 'rgba(255, 107, 107, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0
                            }]
                        };
                    },
                    strengths: [
                        'Profite des "hot streaks" : capitalise sur les s√©ries gagnantes pour acc√©l√©rer',
                        'Plafond de s√©curit√© : streak_limit √©vite l\'escalade incontr√¥l√©e du risque',
                        'Psychologiquement agr√©able : augmente le risque quand la confiance est haute',
                        'Simple √† comprendre et √† param√©trer'
                    ],
                    weaknesses: [
                        'Peut monter le risque juste avant un retournement (fin de s√©rie)',
                        'Ne tient pas compte du drawdown : peut rester agressif m√™me avec DD √©lev√©',
                        'D√©pend de la chance : une s√©rie de 5 gains peut √™tre statistiquement normale',
                        'Reset brutal : une seule perte annule toute la progression'
                    ]
                };
            }

            // ============ S15: Ratio de Sharpe Adaptatif ============
            if (key.includes('strategy_15')) {
                return {
                    chartTitle: 'Risque en fonction du Ratio de Sharpe',
                    xAxisLabel: 'Sharpe Ratio',
                    paramRanges: {
                        'base_risk': { label: 'Risque de base', min: 0.1, max: 5, step: 0.1, unit: '%' },
                        'sharpe_low': { label: 'Sharpe faible', min: 0, max: 1, step: 0.1, unit: '' },
                        'sharpe_high': { label: 'Sharpe √©lev√©', min: 1.5, max: 3, step: 0.1, unit: '' },
                        'low_risk': { label: 'Risque Sharpe faible', min: 0.1, max: 1, step: 0.1, unit: '%' },
                        'high_risk': { label: 'Risque Sharpe √©lev√©', min: 1, max: 3, step: 0.1, unit: '%' }
                    },
                    generateData: (params) => {
                        const labels = [];
                        const risks = [];
                        const sharpe_low = params.sharpe_low || 0.5;
                        const sharpe_high = params.sharpe_high || 2;
                        const low_risk = params.low_risk || 0.5;
                        const high_risk = params.high_risk || 2;
                        
                        for (let sharpe = 0; sharpe <= 3; sharpe += 0.1) {
                            labels.push(sharpe.toFixed(1));
                            
                            let risk;
                            if (sharpe <= sharpe_low) {
                                risk = low_risk;
                            } else if (sharpe >= sharpe_high) {
                                risk = high_risk;
                            } else {
                                const ratio = (sharpe - sharpe_low) / (sharpe_high - sharpe_low);
                                risk = low_risk + (ratio * (high_risk - low_risk));
                            }
                            
                            risks.push(risk);
                        }
                        
                        return {
                            labels: labels,
                            datasets: [{
                                label: 'Risque (%)',
                                data: risks,
                                borderColor: '#3f51b5',
                                backgroundColor: 'rgba(63, 81, 181, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0.4
                            }]
                        };
                    },
                    strengths: [
                        'M√©trique sophistiqu√©e : combine rendement ET volatilit√© pour √©valuer la qualit√© de la performance',
                        'R√©compense la r√©gularit√© : favorise les strat√©gies avec gains constants plut√¥t que erratiques',
                        'Standard de l\'industrie financi√®re : m√©trique reconnue et valid√©e',
                        'D√©tecte automatiquement les p√©riodes de haute qualit√© de trading vs. p√©riodes m√©diocres'
                    ],
                    weaknesses: [
                        'Calcul complexe n√©cessitant un historique cons√©quent pour √™tre fiable',
                        'Peut mal r√©agir aux changements brusques : Sharpe √©lev√© avant un krach',
                        'D√©pend fortement de la fen√™tre de calcul choisie (court terme vs. long terme)',
                        'Ne distingue pas volatilit√© positive (gros gains) de n√©gative (grosses pertes)'
                    ]
                };
            }

            // ============ S16, S17, S18: Combinaisons Multi-Signaux ============
            if (key === 'strategy_16' || key === 'strategy_17' || key === 'strategy_18') {
                return {
                    chartTitle: 'Risque selon Combinaison de Signaux',
                    xAxisLabel: 'Score de condition de march√© (-3 √† +3)',
                    paramRanges: {
                        'base_risk': { label: 'Risque de base', min: 0.1, max: 5, step: 0.1, unit: '%' },
                        'threshold_low': { label: 'Seuil bas', min: -3, max: 0, step: 0.5, unit: '' },
                        'threshold_high': { label: 'Seuil haut', min: 0, max: 3, step: 0.5, unit: '' },
                        'risk_reduction': { label: 'R√©duction risque', min: 0.3, max: 0.8, step: 0.1, unit: '' },
                        'risk_increase': { label: 'Augmentation risque', min: 1.2, max: 2, step: 0.1, unit: '' }
                    },
                    generateData: (params) => {
                        const labels = [];
                        const risks = [];
                        const base_risk = params.base_risk || 1.0;
                        const threshold_low = params.threshold_low || -1;
                        const threshold_high = params.threshold_high || 1;
                        const risk_reduction = params.risk_reduction || 0.5;
                        const risk_increase = params.risk_increase || 1.5;
                        
                        for (let score = -3; score <= 3; score += 0.2) {
                            labels.push(score.toFixed(1));
                            
                            let risk;
                            if (score <= threshold_low) {
                                risk = base_risk * risk_reduction;
                            } else if (score >= threshold_high) {
                                risk = base_risk * risk_increase;
                            } else {
                                risk = base_risk;
                            }
                            
                            risks.push(risk);
                        }
                        
                        return {
                            labels: labels,
                            datasets: [{
                                label: 'Risque (%)',
                                data: risks,
                                borderColor: '#ff5722',
                                backgroundColor: 'rgba(255, 87, 34, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0.4
                            }]
                        };
                    },
                    strengths: [
                        'Approche holistique : combine plusieurs m√©triques pour une vision compl√®te du contexte',
                        'Plus robuste que les strat√©gies mono-crit√®re : moins de faux signaux',
                        'Permet de capturer des situations complexes (ex: DD mod√©r√© + volatilit√© √©lev√©e + s√©rie de pertes)',
                        'Tr√®s personnalisable : pond√©ration des facteurs selon les pr√©f√©rences du trader'
                    ],
                    weaknesses: [
                        'Complexit√© : difficile de comprendre pourquoi le risque change √† un moment donn√©',
                        'Sur-optimisation : risque de fit parfait sur donn√©es pass√©es mais inefficace en live',
                        'N√©cessite beaucoup de donn√©es pour valider la combinaison de param√®tres',
                        'Maintenance difficile : doit r√©√©valuer les pond√©rations r√©guli√®rement'
                    ]
                };
            }

            // ============ S19: Time-Based Risk (Heure de la journ√©e) ============
            if (key.includes('strategy_19')) {
                return {
                    chartTitle: 'Risque en fonction de l\'Heure de Trading',
                    xAxisLabel: 'Heure de la journ√©e',
                    paramRanges: {
                        'base_risk': { label: 'Risque de base', min: 0.1, max: 5, step: 0.1, unit: '%' },
                        'peak_start': { label: 'D√©but pic', min: 8, max: 14, step: 1, unit: 'h' },
                        'peak_end': { label: 'Fin pic', min: 14, max: 20, step: 1, unit: 'h' },
                        'peak_risk': { label: 'Risque pic', min: 1, max: 3, step: 0.1, unit: '%' },
                        'off_risk': { label: 'Risque off-peak', min: 0.1, max: 1, step: 0.1, unit: '%' }
                    },
                    generateData: (params) => {
                        const labels = [];
                        const risks = [];
                        const peak_start = params.peak_start || 9;
                        const peak_end = params.peak_end || 16;
                        const peak_risk = params.peak_risk || 1.5;
                        const off_risk = params.off_risk || 0.5;
                        
                        for (let hour = 0; hour < 24; hour++) {
                            labels.push(hour + 'h');
                            risks.push((hour >= peak_start && hour <= peak_end) ? peak_risk : off_risk);
                        }
                        
                        return {
                            labels: labels,
                            datasets: [{
                                label: 'Risque (%)',
                                data: risks,
                                borderColor: '#ff9800',
                                backgroundColor: 'rgba(255, 152, 0, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0
                            }]
                        };
                    },
                    strengths: [
                        'Exploite les patterns de liquidit√© : plus de risque pendant les heures de forte activit√©',
                        'R√©duit le risque pendant les p√©riodes creuses (spreads larges, slippage √©lev√©)',
                        'Adapt√© aux march√©s avec horaires sp√©cifiques (ouvertures de bourses, news √©conomiques)',
                        'Peut √©viter les gap overnight en r√©duisant le risque en fin de journ√©e'
                    ],
                    weaknesses: [
                        'Simpliste : ignore les conditions de march√© r√©elles (un crash √† 10h reste dangereux)',
                        'Pas adapt√© au trading 24/7 (crypto) o√π la notion d\'horaire est moins pertinente',
                        'Peut manquer des opportunit√©s hors heures de pic',
                        'Les horaires optimaux changent selon les actifs et √©voluent dans le temps'
                    ]
                };
            }

            // ============ S20: Mod√®le Lin√©aire 3 Signaux ============
            if (key.includes('strategy_20')) {
                return {
                    chartTitle: 'Contribution des 3 Facteurs au Risque Final',
                    xAxisLabel: 'Valeur normalis√©e du facteur',
                    paramRanges: {
                        'base_risk': { label: 'Risque de base', min: 0.1, max: 5, step: 0.1, unit: '%' },
                        'a': { label: 'Poids DD', min: 0, max: 1, step: 0.1, unit: '' },
                        'b': { label: 'Poids Wins', min: 0, max: 1, step: 0.1, unit: '' },
                        'c': { label: 'Poids Volatilit√©', min: 0, max: 1, step: 0.1, unit: '' }
                    },
                    generateData: (params) => {
                        const labels = [];
                        const dd_contrib = [];
                        const wins_contrib = [];
                        const vol_contrib = [];
                        
                        const a = params.a || 0.3;
                        const b = params.b || 0.4;
                        const c = params.c || 0.3;
                        const total = a + b + c;
                        
                        for (let val = -1; val <= 1; val += 0.1) {
                            labels.push(val.toFixed(1));
                            dd_contrib.push((a / total) * (1 + val));
                            wins_contrib.push((b / total) * (1 + val));
                            vol_contrib.push((c / total) * (1 + val));
                        }
                        
                        return {
                            labels: labels,
                            datasets: [
                                {
                                    label: 'Contribution DD',
                                    data: dd_contrib,
                                    borderColor: '#e74c3c',
                                    backgroundColor: 'rgba(231, 76, 60, 0.1)',
                                    borderWidth: 2,
                                    fill: false
                                },
                                {
                                    label: 'Contribution Wins',
                                    data: wins_contrib,
                                    borderColor: '#28a745',
                                    backgroundColor: 'rgba(40, 167, 69, 0.1)',
                                    borderWidth: 2,
                                    fill: false
                                },
                                {
                                    label: 'Contribution Volatilit√©',
                                    data: vol_contrib,
                                    borderColor: '#9c27b0',
                                    backgroundColor: 'rgba(156, 39, 176, 0.1)',
                                    borderWidth: 2,
                                    fill: false
                                }
                            ]
                        };
                    },
                    strengths: [
                        'Mod√®le quantitatif transparent : chaque facteur a un poids explicite et ajustable',
                        '√âquilibre personnalisable : vous d√©cidez ce qui compte le plus (DD, performance, volatilit√©)',
                        'Facilement testable et optimisable avec des donn√©es historiques',
                        'Approche scientifique : s\'inspire de la r√©gression lin√©aire utilis√©e en finance quantitative'
                    ],
                    weaknesses: [
                        'Suppose une relation lin√©aire entre facteurs et risque optimal (rarement vrai)',
                        'Les poids doivent √™tre recalibr√©s r√©guli√®rement selon les conditions de march√©',
                        'Risque de sur-optimisation : parfait sur le pass√©, inefficace en forward testing',
                        'Ne capture pas les interactions non-lin√©aires entre facteurs (ex: DD √©lev√© + volatilit√© forte)'
                    ]
                };
            }

            // ============ S21: R-Counter ============
            if (key.includes('strategy_21')) {
                return {
                    chartTitle: 'Risque en fonction du Compteur R cumulatif',
                    xAxisLabel: 'Compteur R (gains/pertes cumul√©s)',
                    paramRanges: {
                        'step_1': { label: 'Palier 1', min: 1, max: 20, step: 1, unit: 'R' },
                        'step_2': { label: 'Palier 2', min: 5, max: 30, step: 1, unit: 'R' },
                        'step_3': { label: 'Palier 3', min: 10, max: 50, step: 1, unit: 'R' },
                        'risk_neutral': { label: 'Risque neutre', min: 0.1, max: 5, step: 0.1, unit: '%' },
                        'risk_up_1': { label: 'Risque +palier 1', min: 0.5, max: 5, step: 0.1, unit: '%' },
                        'risk_up_2': { label: 'Risque +palier 2', min: 1, max: 10, step: 0.1, unit: '%' },
                        'risk_up_3': { label: 'Risque +palier 3', min: 1, max: 15, step: 0.1, unit: '%' },
                        'risk_down_1': { label: 'Risque -palier 1', min: 0.1, max: 2, step: 0.1, unit: '%' },
                        'risk_down_2': { label: 'Risque -palier 2', min: 0.1, max: 1, step: 0.05, unit: '%' },
                        'risk_down_3': { label: 'Risque -palier 3', min: 0.05, max: 0.5, step: 0.05, unit: '%' },
                        'reset_dd_threshold': { label: 'Reset DD seuil', min: 10, max: 50, step: 5, unit: '%' }
                    },
                    generateData: (params) => {
                        const labels = [];
                        const risks = [];
                        
                        const step_1 = params.step_1 || 5;
                        const step_2 = params.step_2 || 10;
                        const step_3 = params.step_3 || 15;
                        const risk_neutral = params.risk_neutral || 1.0;
                        const risk_up_1 = params.risk_up_1 || 1.5;
                        const risk_up_2 = params.risk_up_2 || 2.0;
                        const risk_up_3 = params.risk_up_3 || 3.0;
                        const risk_down_1 = params.risk_down_1 || 0.5;
                        const risk_down_2 = params.risk_down_2 || 0.25;
                        const risk_down_3 = params.risk_down_3 || 0.1;
                        
                        // G√©n√©rer le graphe de -20R √† +20R
                        for (let r = -20; r <= 20; r += 1) {
                            labels.push(`${r}R`);
                            
                            let risk;
                            if (r >= step_3) {
                                risk = risk_up_3;
                            } else if (r >= step_2) {
                                risk = risk_up_2;
                            } else if (r >= step_1) {
                                risk = risk_up_1;
                            } else if (r > -step_1) {
                                risk = risk_neutral;
                            } else if (r > -step_2) {
                                risk = risk_down_1;
                            } else if (r > -step_3) {
                                risk = risk_down_2;
                            } else {
                                risk = risk_down_3;
                            }
                            
                            risks.push(risk);
                        }
                        
                        return {
                            labels: labels,
                            datasets: [{
                                label: 'Risque appliqu√© (%)',
                                data: risks,
                                borderColor: '#667eea',
                                backgroundColor: 'rgba(102, 126, 234, 0.2)',
                                borderWidth: 3,
                                fill: true,
                                stepped: 'middle'
                            }]
                        };
                    },
                    strengths: [
                        'Mesure objective de la performance en unit√©s de risque (R), ind√©pendante du capital',
                        'Augmente le risque quand vous √™tes "chaud" (compteur positif)',
                        'R√©duit drastiquement le risque en cas de s√©rie n√©gative (protection capital)',
                        'Reset automatique sur DD : si DD > seuil, compteur remis √† z√©ro (fresh start)'
                    ],
                    weaknesses: [
                        'Le reset peut effacer un historique positif en cas de DD temporaire',
                        'Sans reset, une grosse perte ancienne peut handicaper longtemps',
                        'Peut rester agressif m√™me en drawdown si les gains pass√©s compensent (avant reset)',
                        'Les paliers sont arbitraires : n√©cessite optimisation pour votre style de trading'
                    ]
                };
            }

            // Configuration par d√©faut (ne devrait jamais √™tre utilis√©)
            return {
                chartTitle: 'Comportement de la strat√©gie',
                xAxisLabel: 'Param√®tre X',
                paramRanges: {},
                generateData: () => ({ labels: [], datasets: [] }),
                strengths: ['√Ä d√©finir'],
                weaknesses: ['√Ä d√©finir']
            };
        }

        // Initialiser au chargement
        document.addEventListener('DOMContentLoaded', () => {
            initializeStrategies();
        });
    </script>
</body>
</html>
